<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width">
    <link rel="stylesheet" href="./styles.css"></link>
    <title>Data Structures Documentation</title>
  </head>
  <body>
    <main id="main-doc">
      <nav id="navbar" class="nav">
      <header>
        Data Structures
      </header>
      <ul>
          <li><a class="nav-link" href="#Introduction">Introduction</a></li>
          <li><a class="nav-link" href="#Arrays">Arrays</a></li>
        <li><a class="nav-link" href="#Hash_Tables">Hash Tables</a></li>
        <li><a class="nav-link" href="#Linked_Lists">Linked Lists</a></li>
        <li><a class="nav-link" href="#Stacks">Stacks</a></li>
        <li><a class="nav-link" href="#Queues">Queues</a></li>
        <li><a class="nav-link" href="#Trees">Trees</a></li>
        <li><a class="nav-link" href="#Graphs">Graphs</a></li>
        <li><a class="nav-link" href="#Reference">Reference</a></li>
      </ul>
    </nav>

      <section class="main-section" role="region" aria-labelledby="Introduction" id="Introduction">
        <header id="Introduction">
          <h1>Introduction</h1> 
        </header>
        <body>
          <p>Data structures are fundamental concepts in computer science that organize and store data in a way that enables efficient access and modification. They are the building blocks for creating efficient algorithms and managing data in applications. Each data structure is suited to a particular kind of task, and choosing the right data structure can significantly affect the performance of a program.</p>
          <p>The Data Structures we will be covering are:</p>
          <ul>
            <li><a href="#Introduction">Introduction</a></li>
        <li><a  href="#Arrays">Arrays</a></li>
        <li><a href="#Hash_Tables">Hash Tables</a></li>
        <li><a  href="#Linked_Lists">Linked Lists</a></li>
        <li><a href="#Stacks">Stacks</a></li>
        <li><a  href="#Queues">Queues</a></li>
        <li><a href="#Trees">Trees</a></li>
        <li><a href="#Graphs">Graphs</a></li>
        <li><a href="#Reference">Reference</a></li>
          </ul>
        </body>
      </section>

      <section class="main-section" role="region" aria-labelledby="Arrays" id="Arrays">
        <header id="Arrays">
          <h1>Arrays</h1>
        </header>
        <body>
          <p>A collection of elements, each identified by an index. All elements are stored in contiguous memory locations, which allows for efficient access and modification.</p>
          <p>Example: [1, 2, 3, 4, 5]</p>
          <h3>C++ Code Implementation:</h3>
          <pre><code>
#include &lt;iostream&gt;

int main() {
    // Declare and initialize an array of integers
    int arr[5] = {10, 20, 30, 40, 50};

    // Access and print the elements of the array
    std::cout &lt;&lt; "Elements of the array: ";
    for (int i = 0; i &lt; 5; i++) {
        std::cout &lt;&lt; arr[i] &lt;&lt; " ";
    }

    // Modify an element
    arr[2] = 35;

    std::cout &lt;&lt; "\nModified array: ";
    for (int i = 0; i &lt; 5; i++) {
        std::cout &lt;&lt; arr[i] &lt;&lt; " ";
    }

    return 0;
}
</code></pre>

    <h3>Python Code Implementation:</h3>
    <pre><code>
# Declare and initialize an array (list) of integers
arr = [10, 20, 30, 40, 50]

# Access and print the elements of the array
print("Elements of the array:", arr)

# Modify an element
arr[2] = 35

print("Modified array:", arr)
    </code></pre>

        </body>
      </section>

      <section class="main-section" role="region" aria-labelledby="Hash_Tables" id="Hash_Tables">
        <header id="Hash_Tables">
          <h1>Hash Tables</h1> 
        </header>
        <body>
          <p>A data structure that maps keys to values for efficient lookup. It uses a hash function to compute an index into an array of buckets or slots, from which the desired value can be found.
</p>
<p>Example: Dictionary in Python where keys are mapped to values.</p>
<h3>C++ Code Implementation:</h3>
          <pre><code>#include <iostream>
#include <unordered_map>

int main() {
    // Declare an unordered_map to represent the hash table
    std::unordered_map<std::string, int> hashTable;

    // Insert key-value pairs into the hash table
    hashTable["apple"] = 50;
    hashTable["banana"] = 30;
    hashTable["orange"] = 20;

    // Access and print elements by key
    std::cout << "The price of an apple is: " << hashTable["apple"] << std::endl;

    // Check if a key exists in the hash table
    if (hashTable.find("banana") != hashTable.end()) {
        std::cout << "Banana is available, and its price is: " << hashTable["banana"] << std::endl;
    } else {
        std::cout << "Banana is not available." << std::endl;
    }

    // Modify a value associated with a key
    hashTable["orange"] = 25;

    // Iterate and print all key-value pairs
    std::cout << "All items in the hash table:" << std::endl;
    for (const auto& item : hashTable) {
        std::cout << item.first << ": " << item.second << std::endl;
    }

    return 0;
}</code></pre>

<h3>Python Code Implementation:</h3>
<pre><code># Create a dictionary to represent the hash table
hash_table = {
    "apple": 50,
    "banana": 30,
    "orange": 20
}

# Access and print elements by key
print("The price of an apple is:", hash_table["apple"])

# Check if a key exists in the hash table
if "banana" in hash_table:
    print("Banana is available, and its price is:", hash_table["banana"])
else:
    print("Banana is not available.")

# Modify a value associated with a key
hash_table["orange"] = 25

# Iterate and print all key-value pairs
print("All items in the hash table:")
for key, value in hash_table.items():
    print(f"{key}: {value}")
</code></pre>
        </body>
      </section>

      <section class="main-section" role="region" aria-labelledby="Linked_Lists" id="Linked_Lists">
        <header id="Linked_Lists">
          <h1>Linked Lists</h1> 
        </header>
        <body>
          <p>A linear collection of elements, called nodes, where each node contains a data value and a reference (or link) to the next node in the sequence. This structure allows for efficient insertion and deletion.</p>
          <p>Types: Singly Linked List, Doubly Linked List, Circular Linked List.</p>
          <h3>C++ Code Implementation:</h3>
          <pre><code>#include <iostream>

// Define the Node structure
struct Node {
    int data;
    Node* next;
};

// Function to create a new node
Node* createNode(int data) {
    Node* newNode = new Node();
    newNode->data = data;
    newNode->next = nullptr;
    return newNode;
}

// Function to insert a node at the end of the linked list
void insertAtEnd(Node*& head, int data) {
    Node* newNode = createNode(data);
    if (head == nullptr) {
        head = newNode;
    } else {
        Node* temp = head;
        while (temp->next != nullptr) {
            temp = temp->next;
        }
        temp->next = newNode;
    }
}

// Function to print the linked list
void printList(Node* head) {
    Node* temp = head;
    while (temp != nullptr) {
        std::cout << temp->data << " -> ";
        temp = temp->next;
    }
    std::cout << "NULL" << std::endl;
}

int main() {
    Node* head = nullptr;

    insertAtEnd(head, 10);
    insertAtEnd(head, 20);
    insertAtEnd(head, 30);
    insertAtEnd(head, 40);

    std::cout << "Linked List: ";
    printList(head);

    return 0;
}
</code></pre>

          <h3>Python Code Implementation:</h3>
          <pre><code># Define the Node class
class Node:
    def __init__(self, data):
        self.data = data
        self.next = None

# Define the LinkedList class
class LinkedList:
    def __init__(self):
        self.head = None

    # Method to insert a node at the end
    def insert_at_end(self, data):
        new_node = Node(data)
        if not self.head:
            self.head = new_node
        else:
            temp = self.head
            while temp.next:
                temp = temp.next
            temp.next = new_node

    # Method to print the linked list
    def print_list(self):
        temp = self.head
        while temp:
            print(temp.data, end=" -> ")
            temp = temp.next
        print("None")

# Example usage
if __name__ == "__main__":
    ll = LinkedList()
    ll.insert_at_end(10)
    ll.insert_at_end(20)
    ll.insert_at_end(30)
    ll.insert_at_end(40)

    print("Linked List:", end=" ")
    ll.print_list()
</code></pre>
        </body>
      </section>

      <section class="main-section" role="region" aria-labelledby="Stacks" id="Stacks">
        <header id="Stacks">
          <h1>Stacks</h1> 
        </header>
        <body>
          <p>A linear data structure that follows the Last In, First Out (LIFO) principle. Elements are added and removed from the same end, known as the "top."</p>
          <p>Example: A stack of plates where you can only take the top plate off.</p>
          <h3>C++ Code Implementation:</h3>
          <pre><code>#include <iostream>
#define MAX 1000

class Stack {
    int top;

public:
    int arr[MAX]; // Maximum size of Stack

    Stack() { top = -1; } // Constructor initializes top as -1

    bool push(int x);
    int pop();
    int peek();
    bool isEmpty();
};

// Function to add an element to the stack
bool Stack::push(int x) {
    if (top >= (MAX - 1)) {
        std::cout << "Stack Overflow" << std::endl;
        return false;
    } else {
        arr[++top] = x;
        std::cout << x << " pushed into stack" << std::endl;
        return true;
    }
}

// Function to remove an element from the stack
int Stack::pop() {
    if (top < 0) {
        std::cout << "Stack Underflow" << std::endl;
        return 0;
    } else {
        int x = arr[top--];
        return x;
    }
}

// Function to return the top element of the stack
int Stack::peek() {
    if (top < 0) {
        std::cout << "Stack is Empty" << std::endl;
        return 0;
    } else {
        int x = arr[top];
        return x;
    }
}

// Function to check if the stack is empty
bool Stack::isEmpty() {
    return (top < 0);
}

// Main function to demonstrate stack operations
int main() {
    Stack stack;
    stack.push(10);
    stack.push(20);
    stack.push(30);
    std::cout << stack.pop() << " popped from stack" << std::endl;
    std::cout << "Top element is " << stack.peek() << std::endl;
    std::cout << "Stack is empty: " << stack.isEmpty() << std::endl;
    return 0;
}
</code></pre>

          <h3>Python Code Implementation:</h3>
          <pre><code>class Stack:
    def __init__(self):
        self.stack = []

    # Function to add an element to the stack
    def push(self, data):
        self.stack.append(data)
        print(f"{data} pushed into stack")

    # Function to remove an element from the stack
    def pop(self):
        if len(self.stack) == 0:
            return "Stack Underflow"
        return self.stack.pop()

    # Function to return the top element of the stack
    def peek(self):
        if len(self.stack) == 0:
            return "Stack is Empty"
        return self.stack[-1]

    # Function to check if the stack is empty
    def is_empty(self):
        return len(self.stack) == 0

# Main function to demonstrate stack operations
if __name__ == "__main__":
    stack = Stack()
    stack.push(10)
    stack.push(20)
    stack.push(30)
    print(f"{stack.pop()} popped from stack")
    print(f"Top element is {stack.peek()}")
    print(f"Stack is empty: {stack.is_empty()}")
</code></pre>
        </body>
      </section>

      <section class="main-section" role="region" aria-labelledby="Queues" id="Queues">
        <header id="Queues">
          <h1>Queues</h1> 
        </header>
        <body>
          <p>A linear data structure that follows the First In, First Out (FIFO) principle. Elements are added at the rear and removed from the front.</p>
          <p>Example: A line of people waiting for a service.</p>
          <h3>C++ Code Implementation:</h3>
          <pre><code>#include <iostream>
#define MAX 1000

class Queue {
    int front, rear, size;
    int arr[MAX]; // Maximum size of Queue

public:
    Queue() {
        front = rear = 0;
        size = 0;
    }

    bool enqueue(int x);
    int dequeue();
    int peek();
    bool isEmpty();
};

// Function to add an element to the queue
bool Queue::enqueue(int x) {
    if (rear == MAX) {
        std::cout << "Queue Overflow" << std::endl;
        return false;
    } else {
        arr[rear++] = x;
        size++;
        std::cout << x << " enqueued into queue" << std::endl;
        return true;
    }
}

// Function to remove an element from the queue
int Queue::dequeue() {
    if (isEmpty()) {
        std::cout << "Queue Underflow" << std::endl;
        return 0;
    } else {
        int x = arr[front++];
        size--;
        return x;
    }
}

// Function to return the front element of the queue
int Queue::peek() {
    if (isEmpty()) {
        std::cout << "Queue is Empty" << std::endl;
        return 0;
    } else {
        return arr[front];
    }
}

// Function to check if the queue is empty
bool Queue::isEmpty() {
    return (size == 0);
}

// Main function to demonstrate queue operations
int main() {
    Queue queue;
    queue.enqueue(10);
    queue.enqueue(20);
    queue.enqueue(30);
    std::cout << queue.dequeue() << " dequeued from queue" << std::endl;
    std::cout << "Front element is " << queue.peek() << std::endl;
    std::cout << "Queue is empty: " << queue.isEmpty() << std::endl;
    return 0;
}
</code></pre>

          <h3>Python Code Implementation:</h3>
          <pre><code>class Queue:
    def __init__(self):
        self.queue = []

    # Function to add an element to the queue
    def enqueue(self, data):
        self.queue.append(data)
        print(f"{data} enqueued into queue")

    # Function to remove an element from the queue
    def dequeue(self):
        if len(self.queue) == 0:
            return "Queue Underflow"
        return self.queue.pop(0)

    # Function to return the front element of the queue
    def peek(self):
        if len(self.queue) == 0:
            return "Queue is Empty"
        return self.queue[0]

    # Function to check if the queue is empty
    def is_empty(self):
        return len(self.queue) == 0

# Main function to demonstrate queue operations
if __name__ == "__main__":
    queue = Queue()
    queue.enqueue(10)
    queue.enqueue(20)
    queue.enqueue(30)
    print(f"{queue.dequeue()} dequeued from queue")
    print(f"Front element is {queue.peek()}")
    print(f"Queue is empty: {queue.is_empty()}")
</code></pre>
        </body>
      </section>

      <section class="main-section" role="region" aria-labelledby="Trees" id="Trees">
        <header id="Trees">
          <h1>Trees</h1>
        </header>
        <body>
          <p>A hierarchical data structure consisting of nodes, where each node has a value and references to child nodes. The topmost node is called the root, and nodes with no children are called leaves.</p>
          <p>Types: Binary Tree, Binary Search Tree, AVL Tree, B-Tree.</p>
          <h3>C++ Code Implementation [Binary Tree]:</h3>
          <pre><code>#include <iostream>

// Node structure definition
struct Node {
    int data;
    Node* left;
    Node* right;

    Node(int val) {
        data = val;
        left = right = nullptr;
    }
};

// Function to insert a node in a binary tree
Node* insert(Node* root, int data) {
    if (root == nullptr) {
        return new Node(data);
    }

    if (data < root->data) {
        root->left = insert(root->left, data);
    } else if (data > root->data) {
        root->right = insert(root->right, data);
    }

    return root;
}

// Function to perform in-order traversal
void inOrder(Node* root) {
    if (root != nullptr) {
        inOrder(root->left);
        std::cout << root->data << " ";
        inOrder(root->right);
    }
}

// Function to perform pre-order traversal
void preOrder(Node* root) {
    if (root != nullptr) {
        std::cout << root->data << " ";
        preOrder(root->left);
        preOrder(root->right);
    }
}

// Function to perform post-order traversal
void postOrder(Node* root) {
    if (root != nullptr) {
        postOrder(root->left);
        postOrder(root->right);
        std::cout << root->data << " ";
    }
}

int main() {
    Node* root = nullptr;
    root = insert(root, 50);
    insert(root, 30);
    insert(root, 20);
    insert(root, 40);
    insert(root, 70);
    insert(root, 60);
    insert(root, 80);

    std::cout << "In-order traversal: ";
    inOrder(root);
    std::cout << std::endl;

    std::cout << "Pre-order traversal: ";
    preOrder(root);
    std::cout << std::endl;

    std::cout << "Post-order traversal: ";
    postOrder(root);
    std::cout << std::endl;

    return 0;
}
</code></pre>

          <h3>Python Code Implementation [Binary Tree]:</h3>
          <pre><code># Node class definition
class Node:
    def __init__(self, data):
        self.data = data
        self.left = None
        self.right = None

# Function to insert a node in a binary tree
def insert(root, data):
    if root is None:
        return Node(data)
    
    if data < root.data:
        root.left = insert(root.left, data)
    else:
        root.right = insert(root.right, data)
    
    return root

# Function to perform in-order traversal
def in_order(root):
    if root:
        in_order(root.left)
        print(root.data, end=" ")
        in_order(root.right)

# Function to perform pre-order traversal
def pre_order(root):
    if root:
        print(root.data, end=" ")
        pre_order(root.left)
        pre_order(root.right)

# Function to perform post-order traversal
def post_order(root):
    if root:
        post_order(root.left)
        post_order(root.right)
        print(root.data, end=" ")

# Example usage
if __name__ == "__main__":
    root = None
    root = insert(root, 50)
    insert(root, 30)
    insert(root, 20)
    insert(root, 40)
    insert(root, 70)
    insert(root, 60)
    insert(root, 80)

    print("In-order traversal: ", end="")
    in_order(root)
    print()

    print("Pre-order traversal: ", end="")
    pre_order(root)
    print()

    print("Post-order traversal: ", end="")
    post_order(root)
    print()
</code></pre>
        </body>
      </section>

      <section class="main-section" role="region" aria-labelledby="Graphs" id="Graphs">
        <header id="Graphs">
          <h1>Graphs</h1> 
        </header>
        <body>
          <p>A collection of nodes, called vertices, and the connections between them, called edges. Graphs can be used to represent networks, such as social networks or transportation systems.
</p>
          <p>Types: Directed Graph, Undirected Graph, Weighted Graph, Unweighted Graph.</p>
          <h3>C++ Code Implementation:</h3>
          <pre><code>#include <iostream>
#include <list>
#include <vector>

class Graph {
    int V; // Number of vertices
    std::vector<std::list<int>> adj; // Pointer to an array containing adjacency lists

public:
    Graph(int V); // Constructor
    void addEdge(int v, int w); // Function to add an edge to graph
    void BFS(int s); // Function to perform BFS traversal
    void DFSUtil(int v, std::vector<bool> &visited); // Utility function for DFS
    void DFS(int v); // Function to perform DFS traversal
};

// Constructor
Graph::Graph(int V) {
    this->V = V;
    adj.resize(V);
}

// Function to add an edge to the graph
void Graph::addEdge(int v, int w) {
    adj[v].push_back(w); // Add w to v’s list.
    adj[w].push_back(v); // Add v to w's list since the graph is undirected
}

// Function to perform BFS traversal from a given source vertex
void Graph::BFS(int s) {
    std::vector<bool> visited(V, false);

    // Create a queue for BFS
    std::list<int> queue;

    // Mark the current node as visited and enqueue it
    visited[s] = true;
    queue.push_back(s);

    while (!queue.empty()) {
        // Dequeue a vertex from the queue and print it
        s = queue.front();
        std::cout << s << " ";
        queue.pop_front();

        // Get all adjacent vertices of the dequeued vertex s
        // If an adjacent has not been visited, then mark it visited and enqueue it
        for (auto adjVertex : adj[s]) {
            if (!visited[adjVertex]) {
                visited[adjVertex] = true;
                queue.push_back(adjVertex);
            }
        }
    }
}

// Utility function for DFS traversal
void Graph::DFSUtil(int v, std::vector<bool> &visited) {
    // Mark the current node as visited and print it
    visited[v] = true;
    std::cout << v << " ";

    // Recur for all the vertices adjacent to this vertex
    for (auto adjVertex : adj[v]) {
        if (!visited[adjVertex]) {
            DFSUtil(adjVertex, visited);
        }
    }
}

// Function to perform DFS traversal from a given vertex v
void Graph::DFS(int v) {
    std::vector<bool> visited(V, false);
    DFSUtil(v, visited);
}

// Main function to demonstrate graph operations
int main() {
    Graph g(5); // Create a graph with 5 vertices

    g.addEdge(0, 1);
    g.addEdge(0, 4);
    g.addEdge(1, 2);
    g.addEdge(1, 3);
    g.addEdge(1, 4);
    g.addEdge(2, 3);
    g.addEdge(3, 4);

    std::cout << "BFS traversal starting from vertex 0:" << std::endl;
    g.BFS(0);

    std::cout << "\nDFS traversal starting from vertex 0:" << std::endl;
    g.DFS(0);

    return 0;
}
</code></pre>

          <h3>Python Code Implementation:</h3>
          <pre><code>from collections import defaultdict

class Graph:
    def __init__(self):
        self.graph = defaultdict(list)  # Default dictionary to store graph

    # Function to add an edge to the graph
    def add_edge(self, u, v):
        self.graph[u].append(v)
        self.graph[v].append(u)  # Since the graph is undirected

    # Function to perform BFS traversal
    def bfs(self, s):
        visited = set()  # Set to keep track of visited vertices
        queue = [s]  # Initialize a queue with the start vertex

        while queue:
            vertex = queue.pop(0)
            if vertex not in visited:
                print(vertex, end=" ")
                visited.add(vertex)
                queue.extend([neighbor for neighbor in self.graph[vertex] if neighbor not in visited])

    # Function to perform DFS traversal
    def dfs(self, v, visited=None):
        if visited is None:
            visited = set()
        visited.add(v)
        print(v, end=" ")
        for neighbor in self.graph[v]:
            if neighbor not in visited:
                self.dfs(neighbor, visited)

# Example usage
if __name__ == "__main__":
    g = Graph()
    g.add_edge(0, 1)
    g.add_edge(0, 4)
    g.add_edge(1, 2)
    g.add_edge(1, 3)
    g.add_edge(1, 4)
    g.add_edge(2, 3)
    g.add_edge(3, 4)

    print("BFS traversal starting from vertex 0:")
    g.bfs(0)

    print("\nDFS traversal starting from vertex 0:")
    g.dfs(0)
</code></pre>
        </body>
      </section>

      <section class="main-section" role="region" aria-labelledby="Reference" id="Reference">
        <header id="Reference">
          <h1>Reference</h1> 
        </header>
        <body>
          <p>The information on this website is taken from chatGPT and the book Cracking the Coding Interview.
</p>
<p>Made by Shubox</p>
        </body>
      </section>
    </main>
  </body>
</html>